**💡 QUIC이란?**

HTTP3에서 추가된 프로토콜.

UDP 기반에 신뢰성과 속도까지 챙긴 프로토콜이다!!

기존 )

TCP : 3 way-handshake ; 신뢰는 챙겼으나 속도가 떨어짐.

UDP : 핸드쉐이크 과정이 없어서 속도는 빠른데 신뢰가 떨어짐.

<img src="https://github.com/JeeeunOh/Major-Study/assets/65931227/1ccd48c4-66de-4f90-b1ff-ebd72d054ec8" height="400px" width="700px">

<br/>

**💡 초기 QUIC?**

핸드쉐이크를 통해 클라이언트, 서버 간의 연결을 설정하는 동시에

TLS 1.3 핸드쉐이크를 통해 인증 & 암호화 매개 변수 협상 수행.

또한, TLS와 달리 추가적인 라운드트립 시간 요구 X

→ 패킷 손실에 강하고 다중 경로와 병렬 데이터 스트림 지원

+) RTT : Round Trip Time : 네트워크 통신에서 발생하는 지연 시간 의미.

데이터가 송신자와 수신자 간에 왕복하는 시간 의미.

<img src="https://github.com/JeeeunOh/Major-Study/assets/65931227/8940e737-808c-4e2f-b77c-91f66a705dd6" height="400px" width="700px">

<br/>

**💡 HTTP 1.1 vs HTTP 2.0**

모두 전송 프로토콜로 TCP 사용.

**`HTTP 1.1`** : 병렬적으로 js, css, png 처리

→ 속도는 빨랐지만 각각 핸드쉐이크를 하기 위한 오버헤드가 발생함.

**`HTTP 2.0`** : 한번의 핸드쉐이크를 통해 오버헤드 줄임. 

→ 핸드쉐이크 한번 + 여러 개의 스트림을 통한 병렬처리

→ 속도를 챙길 수 있었음.

but, **`Head-of-line blocking`** 이 발생할 수 있었음. ( single request기 때문 )

<br/>

**💡 Head-of-line blocking 이란???**

여러 요청 / 응답이 동일한 TCP 연결을 통해 전송되는 경우 발생하는 현상.

네트워크 혼잡으로 인한 패킷 손실과 같은 문제로 인해 발생함.

하나의 요청에만 영향을 미친 데이터가 손실되더라도, 모든 요청/응답이 동등하게 영향받는 현상.

→ 손실된 패킷을 다시 전송받기 전까지 다른 요청/응답은 대기해야함.

전체적인 성능과 응답 시간이 저하될 수 있음.

→ 다중 연결을 지원하는 HTTP2 & QUIC이 등장함.

→ 여러 요청 / 응답을 병렬로 처리하여 Head of line blocking 문제를 해결

<br/>

**💡 QUIC의 등장!**

- QUIC은 UDP 기반
    - TCP는 이미 기준이 확고함 → 수정하기가 어려움.
    - 모든 브라우저들이 UDP를 지원했기 때문에, 충돌이 날 일이 없었음.

<img src="https://github.com/JeeeunOh/Major-Study/assets/65931227/b8503c30-e577-475e-9073-bc0b20776b43" height="400px" width="700px">

<br/>

💡 **TCP 1.3 + TCP** 

- 통신을 해야하는게 많음 → 오버헤드 많아짐
    
    → 이를 QUIC을 통해 통신을 줄임으로써 해결할 수 있음.
    
<img src="https://github.com/JeeeunOh/Major-Study/assets/65931227/4c276573-33db-4ba8-ac4d-7ec48e3ace03" height="400px" width="700px">

<br/>

💡 **reflection attack이란??**

attacker가 IP주소 위조 → victim으로부터 보낸 요청을 반사시킴.

이 때, QUIC은 UDP 기반 프로토콜

→ 공격자는 피해자를 대상으로 하는 QUIC 연결 시도 & 피해자인 척 UDP 패킷 생성

→ 공격자는 이를 반사하여 피해자에게 돌려보냄.

→ 공격자는 응답으로 받은 데이터를 피해자에게 반사시킴 

→ 대량의 트래픽을 피해자로 유도 가능.

⇒ 이를 통해 공격자가 적은 양의 데이터로 대량의 트래픽 생성 가능

: 공격자가 자신의 IP 주소 위조하고, 반사된 응답이 피해자에게서 오도록 조작 가능하기 때문

<br/>

**💡 Deflecting Reflection??**

**`UDP 기반 프로토콜`** 에서 발생하는 reflection 공격의 취약성을 말함.

UDP는 수신한 데이터 패킷을 클라이언트에게 되돌려보내는 기능이 있음.

[ 서버가 보내는 응답 > 받은 요청 ] 일 때, amplification 이라고 함.

서버가 클라이언트 요청에 대해 암호화 연산 등을 수행하기 때문에 발생함.

→ UDP 기반 프로토콜은 이런 증폭 공격에 약함.

공격자가 송신자 주소를 위조하여 대량의 작은 요청을 보내면, 서버는 응답으로 큰 크기의 데이터를 보냄.

→ victim 서버 과부하로 만들 수 있음.

**`TCP`** 는 호기 핸드쉐이크 과정 내 전송되는 패킷들이 모두 동일한 길이 가짐 → 증폭 공격에 사용되지 X

**`QUIC`** 의 핸드쉐이크는 비대칭적 

→ 첫번째 핸드쉐이크 단계에서 인증서 체인과 같은 큰 데이터를 보냄.

클라이언트는 몇 바이트만 보내면 됨.

+) QUIC은 명시적인 소스 주소 검증 매커니즘을 정의함.

→ 서버는 긴 응답을 보내는 대신 훨씬 작은 retry 패킷을 보냄. 

→ 클라이언트 소스 주소 확인 가능 → 클라이언트 유효성 검사 가능 → 증폭 공격 방지 가능.
