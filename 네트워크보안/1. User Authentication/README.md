누가 해킹하거나, 잘못된 접근을 했을 때 시스템은 어떤 유저가 잘못된 접근 권한으로 접근했는지 알아야 함.

- ****identification****
    - 사용자가 신원을 주장하고 시스템이 신원을 검증하는 것
    - 보안 시스템에 식별자 제공 ex. id, pw
- ****verification****
    - 주어진 신원이 실제로 그 사람의 것인지 확인
    - 사용자가 제공한 정보를 검증하고 사용자의 권한을 확인
    
    → identification : 누구인가? / verification : 그 사람이 맞는가?
    
<br/>

💡 ****user identity를 authenticate(인증) 하기위한 수단****

1. individual knows : 내가 나온 초등학교가 어딘지 등
    
    → 타인에게 알려주거나 누설하면 보안에 취약함.
    
2. individual posses : 열쇠, 학생증 등
    
    → 분실, 도난 등으로 물건 자체가 넘어가면 인증이 무용지물
    
    → 카드나 스마트폰이 해킹될 수 있음.
    
3. static biometrics : 지문, 홍채, 얼굴 등
    
    → 해킹되거나 유출될 위험이 거의 없지만, 타인의 지문 등을 위조할 수 있음.
    
4. dynamics biometrics : 보이스패턴, 서체 등
    
    → 환경적 요인이나 개인의 상태에 따라 특성이 변화할 수 있으므로 완벽한 인증이 어려움.
    
    → 타인의 보이스톤 등을 모방 가능
    
<br/>

💡 **Password Authentication**

유저가 아이디, 비번을 데이터베이스에 저장해놓으면 

나중에 시스템에서 유저가 아이디, 비번으로 로그인할 때 이 유저가 실제로 있는지 없는지를 판별함.

이전의 이슈 : etc/passwd 에 들어가면 해시코드나 솔트를 다 볼 수 있었다. 

→ 일반 유저가 해킹 가능했다.

현재 : 패스워드를 모아놓은 파일은 일반 유저들은 읽을 수 없고 관리자만 읽을 수 있음

→ 패스워드 관련돼서 별 이슈가 없다.

<br/>

💡 ****Password Cracking****

1. **BruteForce**
    
    브루트 포스 공격은 가능한 모든 조합을 시도하여 암호를 찾으려고 시도하는 방법
    
    모든 경우를 시도하기 때문에 시도 횟수가 많아지면 매우 비효율적
    
    → 더 복잡하고 긴 암호를 사용하면 방지 가능
    
2. **Dictionary attacks**
    
    사전에 있는 단어들 하나씩 다 도전
    
    → 더 긴 비밀번호를 사용하고, 사전 파일에 없는 단어를 사용하여 암호를 설정하면 이 방법을 방지
    
3. **Rainbow table attacks**
    
    해시함수를 사용하여 만들어낼 수 있는 값들을 왕창 저장한 표
    
    영어 소문자와 숫자 조합으로 일정 길이까지의 모든 문자열에 대해서 계산한다거나 하는 것 
    
    → 복잡한 해시 알고리즘을 사용하고 솔트(Salt)를 적용하여 이 방법을 방지
    
<br/>

💡 **Password Selection Techniques**

1. user education
    1. 빡센 비밀번호 만들기 위해 유저 교육
2. computer generated passwords
    1. 어려운 비밀번호 → 외우기 힘듦
3. reactive password checking
    1. password 크래커가 주기적으로 암호 생성
4. proactive password checking
    1. passwords 크래커가 가지고 있는 암호면 리젝
    2. 사용자가 외우기 쉬우면서 암호크래커가 접근하기 어려운 암호 생성 유도

<br/>

💡 **Biometric Authentication**

패스워드는 고정 string → 매칭 쉬움. but, 생체 인증은 어려움

ex. 지문, 안면인식, 홍채인식, 음성인식 등

- 장단점
    
    장점:
    
    - 비밀번호나 카드키 등과 같은 전통적인 인증 방식에 비해 높은 보안성을 가진다.
    - 생체적인 특성은 본인만이 가지기 때문에 타인이 도용할 수 없다.
    - 인증 과정이 빠르고 간편하다.
    
    단점:
    
    - 장비 구매, 설치, 유지보수 등 초기 비용이 높다.
    - 인식률이 100%가 아니기 때문에 오류가 발생할 수 있다.
    - 인증 과정에서 개인 정보가 수집되기 때문에 개인 정보 보호 문제가 발생할 수 있다.
    - 생체 인증 정보는 바꿀 수 없음 → 탈취당하면 몇번바꾸면 끝임.

<br/>

💡 **Remote User Authentication**

공개키, 개인키의 개념 시작….!

`공개키` : public key : 누구나 접근 가능

`개인키` : private key : 특정 유저만 접근 가능

`공개키 암호 방식 (public-key cryptography)/ 비대칭키 암호 (asymmetric-key algorithm)`

1. **키 이용 방식 )** 
    
    공개키암호 - 공개키 : 암호화 사용 / 개인키 : 복호화 사용
    
    공개키서명 - 공개키 : 서명 검증 / 개인키 : 서명 생성
    
2. **A ↔ B 통신 과정 )**
    1. A가 메시지를 B의 공개키로 암호화 → 암호문 생성
    2. B는 암호문을 B의 개인키로 복호화 → 메시지 원본 생성
    
    → 이 때 암호문 생성 과정에서 리플레이 어택을 막기 위해 
    
    **Time stamp, random nonce**를 집어넣기도 함.
    
    +) 리플레이 어택 당하면 중복된 명령 수행해 잘못된 결과 얻을 수 있음.
    
    ex. 인증된 계좌 이체 메시지가 여러번 재전송되면 금전적 피해를 입을 수 있음.
    
3. **종류 )**
    1. `공개 키 암호` : 특정 비밀키 가지고 있는 사용자만 열어볼 수 있음.
        
        ex. 공개키만 알면 누구나 편지를 넣을 수 있지만 개인키를 가진 사람만 내용을 확인 가능.
        
        ex. RSA
        
    2. `공개 키 서명` : 특정 비밀키로 만들었다는 것을 누구나 확인 가능
        
        ex. 봉인한 편지는 누구나 열어볼 수 있지만 인장확인을 통해 
        
        인장을 소유한 발신자가 이 편지를 보냈음을 증명 가능
        

후에 같은 키로 암호화 & 복호화하는 것도 배움 : `대칭키 암호 (symmetric-key algorithm)`

→ 같은 키 이용하는게 속도가 더 빠름

ex. `TLS` : 공개키 암호 알고리즘으로 대칭키 암호 알고리즘의 공통키 공유

→ 그 키 기반으로 실제 통신의 암호화 구조에 사용함.

<br/>

💡 **FIDO ( Fast ID Online )**

비밀번호나 PIN 등의 기존 인증 방식의 한계를 극복하기 위해 개발됨.

→  비밀번호 대신 생체 인증 정보를 사용하여 인증을 수행합니다. 

이를 통해 보안성을 높이고 인증 과정을 더욱 간편하게 만들 수 있음.

동작과정 )

1. user가 생체정보 이용해서 스마트폰(개인키)에 접근
2. 스마트폰(개인키) ↔ 서버(공개키) 간 안전하게 통신함.
    1. 스마트폰에서 인증을 요청하면 FIDO 클라이언트는 서버로부터 인증 요청 메시지 받음.
    2. 이 메시지는 인증을 위한 임시적인 공개키와 함께 전달됨.
    3. 스마트폰은 이 공개키를 사용하여 사용자의 생체 인증 정보를 암호화해서 서버로 전송함.
    4. 서버는 암호화된 정보를 자신의 개인키로 복호화하여 생체 인증 정보를 확인함.
    5. 서버가 인증에 성공하면 스마트폰과 함께 사용할 수 있는 임시적인 세션키를 생성하고,
        
        이 세션키를 사용하여 암호화된 데이터를 주고 받음.
        
    
    → 스마트폰과 서버 간의 공유 비밀번호를 사용하지 않으므로 보안성이 높음.
    
    각각의 인증 요청마다 고유한 공개키를 사용하기 때문에 리플레이 어택 방지 가능.
    

취약점 )

생체 정보가 탈취되거나 변조될 가능성이 있음.

<br/>

💡 **Authentication Security Issues**

1. eavesdropping
    
    도청. 경로를 도청하여 정보를 유출하는 공격. 암호화와 인증을 통해 방지
    
2. host attacks
    
    인증된 호스트에 대한 공격. 보안 패치를 설치하고 방화벽, 침입 차단 시스템, 침입 검출 시스템 등을 사용하여 방어할 수 있다.
    
3. replay
    
    이미 전송된 메시지를 재전송하여 인증을 우회하는 공격. 타임스탬프나 nonce 등을 사용하여 방지
    
4. client attacks
    
    인증된 클라이언트에 대한 공격. 보안 패치를 설치하고, 클라이언트 인증서를 검증하여 방어 가능
    
5. trojan horse
    
    악성 코드가 숨어있는 프로그램으로 인증을 우회하는 공격. 안티바이러스 프로그램을 사용하여 방어 가능
    
6. denial-of-service
    
    서비스 제공자에 대한 공격으로 서비스가 마비되는 공격. 방화벽, 침입차단시스템, 침입검출시스템 등을 사용하여 방어 가능. 또한 CDN 등의 서비스를 이용하거나 클라우드 서비스를 이용하여 분산 서버를 구성하는 등의 대책을 마련할 수 있다.
