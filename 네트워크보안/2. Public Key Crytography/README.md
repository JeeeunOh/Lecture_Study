**💡 private key crytography**

전통적인 private/secret/single 키 알고리즘은 하나의 키를 사용했고 수신자, 송신자에게 공유됐다. → 보안적인 문제가 생겼다!!

<br/>

**💡 public key crytography**

public, private 두 개의 키를 사용한다. 두 개의 키는 일치하지 않으며 public으로 private을 유추할 수 없다.

- Q. 두 개의 키가 일치하지 않는 이유?
    
    A. 먼저, 공개키는 공개되어 있으며 누구나 알 수 있습니다. 따라서 누구든지 이 공개키로 암호화된 데이터를 전송할 수 있습니다. 그리고 개인키는 오직 소유자만이 알고 있으므로, 이 개인키를 사용하여 암호화된 데이터를 복호화할 수 있습니다.
    
    즉, 공개키와 개인키는 서로 다른 키이며, 서로 다른 작업을 수행합니다. 공개키는 데이터를 암호화하는 데 사용되고, 개인키는 암호화된 데이터를 복호화하는 데 사용됩니다. 이렇게 하면 안전하게 데이터를 전송하고 저장할 수 있습니다.
    
    A. 암호화 한 사람이 복호화하지 못하게 하기 위해, 서명을 검증하는 사람이 서명을 생성하지 못하게 하기 위해
    

두 개의 이슈가 있다.

1. 키 분배 문제 : 어떻게 안전한 통신을 할 수 있는가?
2. 디지털 서명 : 어떻게 메시지가 온전한지 증명?

→ 디피-헬만 알고리즘의 등장!!

<br/>

**💡 public key crytography 알고리즘 쓰임**

1. **encryption/decryption**
2. **digital signatures**
3. **key exchange**

<br/>

**💡 public key crytography 알고리즘 조건**

- 단방향함수여야한다.
    
    → x를 통해 y는 쉽게 찾을 수 있지만, y를 통해 x를 알 수 있으면 안된다.
    
<br/>

**💡 Security of Public Key Schemes**

브루트포스 공격을 하면 이론적으론 얼마든지 가능하다.

다만, 키가 512bits이상으로 상당히 크기 때문에 거의 불가능하다.

또한 키의 크기가 크기 때문에 private key 알고리즘보다 상당히 느리다.

<br/>

**💡 RSA**

public key 알고리즘으로 많이 알려져있다. 

1024 bits의 키를 주로 사용하며 큰 숫자의 소인수분해를 하기 어렵다는 점에 착안하였다.

<br/>

**💡 RSA Key Setup**

1. 두 개의 서로 다른 `p, q`라는 소수를 고른다.
2. 두 수를 곱하여 n = pq를 찾는다.
3. `ø(n)` = (p-1)(q-1)인 ø(n)를 구한다.
4. ø(n)보다 작고 ø(n)와 서로소인 정수 `e`를 찾는다.
5. d*e mod ø(n) = 1 인 `d`를 구한다. 
    
    → d*e = 1 mod ø(n)
    

→ 공개키 : {e, n} , 개인키 {d, n}

<br/>

**💡 RSA En/decryption**

`암호화` : C = M^e mod N

`복호화` : M = C^d mod N

<br/>

**💡 Why RSA Works**

오일러 알고리즘에 의해, C**d = M mod n 이기 때문이다.

→ `복호화` : M = C**d mod n 가 성립함.

+) 오일러 알고리즘 :

두 정수 a와 b의 최대공약수를 구하는 알고리즘

유클리드 알고리즘과 함께 가장 널리 사용되는 최대공약수 알고리즘 중 하나.

핵심 아이디어는 두 수 a와 b의 최대 공약수는 b와 a를 b로 나눈 나머지 r의 최대 공약수와 같다는 것.

즉, gcd(a, b) = gcd ( b, a mod b )이다. 

이 때 오일러 알고리즘은 RSA 알고리즘에서 두 소수의 곱으로부터 

RSA mod n의 오일러 피함수 ø(n) 값을 계산하는 데에 사용됨.

<br/>

**💡 Factoring Problem**

큰 숫자 N을 소수의 곱으로 분해 ( 소인수분해 ) 하기가 힘들다는 점에 착안.

여러 히스토리 끝에 1024 ~ 2048 bit의 RSA가 안전하다고 판단됨.

<br/>

**💡 Diffie-Hellman Key Exchange**

공개키 암호화 시스템의 일종. 비밀키를 공유하기 위해 사용되는 암호화 기법.

두 사람이 하나씩의 비밀값을 가지고 있고 이를 공개하지 않으면서 비밀키를 공유함.

<br/>

**💡Discrete Logarithm Problem ( DLP )**

대표적인 양자 암호학과 디피-헬만 키 교환 알고리즘의 기반이 되는 수학적 문제

DLP는 이산대수적인 연산에서 발생하는 문제로, 어떤 값을 다른 값으로 바꿔주는 함수에서의 연산이 일반적으로 거듭제곱 연산일 때 발생합니다.

간단히 예를 들어서, 어떤 수 a와 b, 그리고 p가 주어졌을 때, a^x ≡ b (mod p)를 만족하는 x를 찾는 것입니다. 여기서 mod는 나머지 연산을 의미합니다.

이 DLP 문제는 계산 복잡도 이론에서 "NP-hard"로 분류되어있어, 큰 숫자를 사용할 경우 브루트포스 공격을 사용해 해를 찾는 것이 거의 불가능합니다. 이러한 특성 때문에 DLP는 매우 강력한 암호화 방식의 기반이 되며, 이러한 특성을 이용해 Diffie-Hellman 키 교환 알고리즘과 같은 고급 암호화 기술이 구현됩니다.

<br/>

**💡 Diffie-Hellman Setup**

1. 어떤 큰 소수 p와 원시근 g를 정합니다.
2. A와 B는 각각 임의의 비밀값 a와 b를 생성합니다.
3. A는 g^a(mod p)를 계산하여 B에게 보냅니다.
4. B는 g^b(mod p)를 계산하여 A에게 보냅니다.
5. A는 받은 B의 값인 g^b(mod p)를 a로 거듭제곱하여 공유키를 만들고, B도 받은 A의 값인 g^a(mod p)를 b로 거듭제곱하여 공유키를 만듭니다.
6. 이제 A와 B는 같은 공유키 값을 가지게 됩니다

이 알고리즘에서 p와 g는 공개되어있으며 a와 b는 각각의 참여자만 알고있음.

**장점 )** 대칭키 암호화 방식과 달리 공개키를 사용하지 않기 때문에, 보안성이 더 높다.

**단점 )** 개인키를 T가 조작해버릴 수 있음. ( Man in the Middle Attack )

→ 보완방법 : TLS를 이용해 상호 간에 맞는 사람인지 인증하고 시작함.

- 중간자 공격이란?
    
    중간자 공격(man-in-the-middle attack)은 통신 상대방을 가로채서 정보를 도용하거나 조작하는 공격 기법입니다. 이 공격 기법은 공개 키 기반의 암호화 시스템에서 특히 취약합니다. 중간자 공격을 실행하려면 공격자는 먼저 통신하는 양쪽 모두의 데이터 흐름을 가로채야 하고, 이후 각각의 연결을 맺은 상대방 역할을 하면서 데이터를 조작할 수 있습니다.
    
    예를 들어, Alice가 Bob에게 보내는 메시지를 Eve라는 공격자가 가로챈다면, Eve는 Bob에게는 Alice인 것처럼 위장하여 Alice가 보낸 메시지를 전송하고, Alice에게는 Bob인 것처럼 위장하여 Bob의 응답 메시지를 받아들일 수 있습니다. 이를 통해 Eve는 Alice와 Bob의 대화를 도청하거나 조작할 수 있습니다.
    
    중간자 공격을 방지하기 위해서는 안전한 인증 과정과 암호화 기법을 사용해야 합니다. 예를 들어, SSL/TLS와 같은 암호화 프로토콜에서는 공개 키 기반의 암호화 기법을 사용하여 통신 상대방의 신원을 검증하고 데이터를 암호화하여 중간자 공격을 막습니다. 또한, 네트워크 보안 시스템을 사용하여 네트워크 트래픽을 검사하고 악성 행위를 감지하고 차단하는 것이 중요합니다.
    
