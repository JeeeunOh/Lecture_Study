**💡 Transport Layer Security**

TLS와 SSL은 컴퓨터 사이의 네트워크 통신에 보안을 제공하는 프로토콜이다.

TLS : 클라 ↔ 서버 커넥트 시 공격자가 커넥트를 읽을 수 있기 때문에,

서버 보호를 위한 클라이언트 인증 정보 & 클라이언트 보호를 위한 서버 인증 정보를 제공한다.

<br/>

**💡 Background ( 속성 )**

- `Confidentiality` : 기밀성
    - 공격자가 데이터를 볼 수 없게 보호함.
    - 데이터의 암호화 & 복호화 제공
- `Integrity` : 무결성
    - 데이터의 원본이 훼손되지 않도록 함.
        
        like 해시 베이스의 HMAC 처럼 무결성 제공
        
- `Availability` : 가용성
    - 인증된 사람에게는 데이터가 사용가능해야한다는 것
- `Authenticity`
    - 인증성 : 상대방의 신원정보를 인증 가능
        - Man in the Middle ( MITM ) 공격같은 걸 막을 수 있음.
- `Non-repudiation`
    - 부인방지 : 송신자가 수신자에게 보낸 정보를 자신이 보내지 않았다고 부정하는 것 방지

<br/>

**💡 Background ( TLS records )**

- SSL/TLS의 key 속성은 다음과 같이 디자인 됨.
    - Handshake 프로토콜
        - 암호화 알고리즘을 위해 만들어진 인증된 Authenticated Key Exchange ( AKE )
    - record 프로토콜
- 추가로 Alert 프로토콜, ChangeCipherSpec 프로토콜

`Handshake 프로토콜`은 암호화 방식을 협상하고, 서로 인증서를 교환하며 세션키를 생성하는 과정을 담당

`Record 프로토콜`은 실제 데이터를 암호화하여 전송하는 과정을 담당.

이 과정을 거쳐 TLS는 안전하고 신뢰성있는 통신을 제공함.

`Handshake`

- TLS 프로토콜 버전 협상
- 암호 알고리즘 선택
- 비대칭키로 서로를 검증함.
- 대칭 암호화를 위해 비밀키 생성

`Record`

- 비밀키로 메시지 암호화
- 암호화된 메시지 전송
- 비밀키로 메시지 복호화
- 메시지의 무결성 검증

자세한 동작원리 by chatGPT

- Handshake 프로토콜
    1. 클라이언트가 서버에 접속하여 TLS 연결 시작
    2. 클라이언트는 서버에게 지원하는 암호화방식과 호환가능한 프로토콜 버전을 알리는 ClientHello 메시지를 보냄.
    3. 서버는 클라이언트의 메시지를 받아들이고, 서버가 지원하는 암호화 방식과 프로토콜 버전을 클라이언트에게 알리는 ServerHello 메시지를 보냄.
    4. 클라이언트와 서버는 서로 인증서를 교환하고 서로의 인증서가 신뢰할 수 있는 것인지 확인
    5. 클라이언트와 서버는 세션 키를 생성하고, 이를 사용하여 암호화된 통신을 시작함.
- Record 프로토콜
    1. Handshake 프로토콜에서 생성한 세션키를 사용하여 데이터를 암호화함.
    2. 암호화된 데이터를 Record 프로토콜에서 전송함.
    3. 데이터를 수신하는 측에서는 Record 프로토콜을 사용하여 데이터를 복호화 함.
- 종료
    1. 통신이 끝날 때는 클라이언트나 서버에서 close_notify 메시지를 전송함.
    2. 상대방이 close_notify 메시지를 받으면, TLS 연결을 종료함.

- TLS가 당할 수 있는 공격 & 해결방안
    1. **중간자 공격 ( Man in the middle attack )**
        
        TLS는 인증 기능을 통해 서버와 클라이언트 간의 통신 안정성을 보장함.
        
        이 때 인증서가 위조될 수 있으며 중간자 공격으로 공격자가 서버와 클라이언트 위조 가능
        
        → 인증서를 발급하는 CA의 신뢰성을 높이고 인증서를 검증해야 함.
        
    2. **리플레이 공격** 
        
        공격자는 기존의 TLS 세션에서 사용된 패킷을 저장하고, 이를 재전송하여 공격 가능.
        
        → Nonce를 ClientHello 값에 포함시켜 패킷의 중복 전송 막기
        
    3. **DDoS 공격**
        
        다수의 컴퓨터를 이용하여 대상 서버에 대량의 요청을 보내 서비스를 마비시키는 공격.
        
        TLS는 대상 서버의 부하를 줄이기 위해 SSL/TLS 핸드쉐이크 과정을 느리게 진행하는 Slowloris, R-U-Dead-Yet 등의 공격 방어
        
    4. 취약한 암호화 사용 (Weak encryption)
    TLS는 RC4 등의 취약한 암호화 방식을 사용하면 공격자가 암호화된 데이터를 복호화할 수 있습니다. TLS는 보다 강력한 암호화 방식을 사용하여 이를 방지합니다.
    5. 서비스 거부 공격 (Denial of Service attack)
    서비스 거부 공격은 대상 서버의 자원을 고갈시켜 서비스를 중단시키는 공격입니다. TLS는 대상 서버의 자원을 점유하는 SSL/TLS 핸드쉐이크 과정을 느리게 진행하는 Slowloris, R-U-Dead-Yet 등의 공격을 방어합니다.
    6. 암호화 취약점 공격 (Cryptographic vulnerability attack)
    암호화 취약점 공격은 암호화 기술 자체에 취약점이 있는 경우를 말합니다. TLS는 취약점이 있는 암호화 기술을 사용하지 않고, 항상 보안성이 검증된

<br/>

**💡TLS : Handshake**

ClientHello :

 무작위 난수 포함

이 난수는 한번만 사용되는 임의의 숫자이기 때문에 **리플레이 어택 막음**

Certificate :

클라이언트는 서버에서 받은 인증서를 검증함. 

ClientKeyExchange :

검증이 완료되면 클라이언트가 생성한 임의의 비밀키를 이용해 서버가 보낸 인증서에 포함된 공개키를 사용해 암호화함. 이렇게 암호화된 비밀키를 ClientKeyExchange에 포함시켜 서버에 보냄.

ChangeCipherSpec :

서버는 전송받은 정보를 복호화해 비밀키를 알아낸 다음 이 비밀키를 통해 세션키를 만들어냄.

클라이언트 또한 비밀키 정보가 있으므로 세션키를 만들어낼 수 있음.

ChangeCiperSpec를 보내 앞으로 모든 통신 내용은 세션키를 사용해 암호화해 보낼 것을 알려줌

Finished :

서버와 클라이언트는 각자 동일한 세션키를 가지고 있으며 

이 키를 사용해 대칭키 암호를 이용하는 통신을 할 수 있음. 

Finished 메시지를 보내 각자의 핸드셰이킹 과정이 끝났음을 알림.

이 때 세션 자체에서 대칭키 암호를 쓰는 이유! : 비대칭키암호는 속도가 느리기 때문

두 가지 방법으로 클라 ↔ 서버 검증 가능

1. **문자열 암호화 등 ( 공개키 암호화 방식 like RSA 등 )**
    
    A가 공개키로 무작위 암호화해서 B에게 보냄.
    
    → B가 개인키로 해독해서 A에게 보냄 → 검증완!
    
    1. 서버는 공개키 인증서를 클라이언트에게 보냄.
    2. 클라이언트는 인증서가 신뢰할 수 있는 인증기관으로부터 발급되었는지 확인함.
    3. 클라이언트는 인증서 안에 있는 서버의 공개키를 추출함.
    4. 클라이언트는 이 공개키를 이용하여 랜덤한 비밀키를 암호화해서 서버에게 보냄.
    5. 서버는 이 랜덤한 비밀키를 자신의 개인키로 복호화해서 비밀키를 생성함.
    6. 클라이언트와 서버는 비밀키를 이용하여 세션키를 생성함.
    
    취약점 )
    
    - 서버의 개인키가 유출될 경우 중간자 공격이 가능함.
    - 서버의 공개키가 인증기관에 의해 인증되었지만 인증기관이 신뢰할 수 없는 경우에도 보안 약화 가능
        
        → 인증서 패칭과 같은 보안 문제가 발생할 수 있음.
        
    - RSA 알고리즘의 처리속도가 느리다는 단점도 있음.
    
2. **전자서명**
    
    A → B에게 M 보냄.
    
    B는 A의 공개키 이용해서 암호화하고 B의 개인키 이용해서 서명
    
    A는 A의 개인키 이용해서 복호화하고 B의 공개키 이용해서 서명 검증
    
    1. 서버는 자신의 **개인키를 이용하여 전자서명을 생성**함.
    2. 클라이언트는 서버로부터 받은 **인증서에서 공개키 추출**
    3. 클라이언트는 인증서에 대한 서버의 전자서명을 검증하기 위해
        
        서버의 **공개키를 사용하여 디지털 서명을 검증**하고 **인증서에서 서버의 신원 정보 추출**
        
    4. 클라이언트는 서버의 **신원 정보 검증**함.
    
    취약점 )
    
    - 인증서를 가져가는 중간자 공격에는 방어가 가능하지만, **전자서명을 위조하는 중간자 공격에는 취약**
        
        → 서버 인증서가 신뢰할 수 있는 것인지 확인해야 함.
        
    - 전자서명을 위한 **개인키를 분실하거나 도난당하면 안됨.**
    
3. **CA 인증서 ( 챗지피티 )**
    1. 클라이언트는 서버에게 연결 요청을 보내고, 
        
        서버는 이에 대한 응답으로 서버 인증서와 자신의 공개키를 전송
        
    2. 클라이언트는 서버 인증서의 유효성을 검사함. 인증서가 CA에 의해 발급되었는지, 
        
        유효기간이 지나지 않았는지 등을 검사함.
        
    3. 클라이언트는 서버의 공개키를 사용하여 비밀키를 생성함.
        
        이 비밀키는 이후 세션키 생성에 사용됨.
        
    4. 클라이언트와 서버가 세션키를 교환함.
    5. 클라이언트와 서버는 서로를 신뢰하고 이후 Record 프로토콜로 데이터 통신을 진행함.
