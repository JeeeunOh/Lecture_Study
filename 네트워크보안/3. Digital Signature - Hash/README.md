공개키암호(public key crytography) - 공개키 : 암호화 사용 / 개인키 : 복호화 사용

공개키서명(Digital Signature) - 공개키 : 서명 검증 / 개인키 : 서명 생성

<br/>

**💡 Ink Signature**

자신이 서명했던 문서의 내용이 바뀔 수도 있음

<br/>

**💡 Digital Signature**

문서 소유주와 time을 검증할 수 있다.

메시지의 진위 여부를 판단할 수 있다.

논란 해결을 위해 제 3자에 의해 판단되어야 함.

<br/>

**💡 Digital signature algorithms**

→ 메시지가 바뀌면 서명도 바뀜.

비밀키로 서명한 걸 공개키로 검증함.

<br/>

**💡 RSA signature algorithm**

단점 ) 

메시지 길어지면 계산 어려워짐.

→ 압축하는 알고리즘 필요

→ h = H(M) : 무한대 길이를 256 비트로 줄일 수 있음.

<br/>

**💡 Hash Functions**

임의의 길이를 고정 사이즈로 압축하는 방법

one-way property : 결과값으로 메시지 찾기 힘듦.

collision-free property : 같은 해시값 가지는 데이터 찾기 힘듦.

<br/>

**💡 디지털서명 + Hash Functions**

**동작 과정 )**

1. 서명자
    1. 해시함수를 이용해서 메시지의 해시값 계산해서 고정크기로 만듦.
    2. 이 해시값을 개인키로 암호화해서 디지털 서명으로 사용함.
    3. 서명자는 해시값과 원본 메시지를 보냄.
    4. 해시값과 원본 메시지를 한번 더 암호화해서 보낼 수도 있음
        
        → 원본 메시지를 공유하지 않고도 서명 유효성 검증이 가능함.
        
    
2. 수신자
    1. 공개키를 사용하여 디지털 서명 복호화
    2. 디지털 서명을 생성한 해시함수를 사용하여 원래 메시지의 해시값 계산

장점 )

- 원래 메시지를 공유하지 않고도 서명 유효성 검증 가능
    
    → 보안과 효율성 면에서 매우 유용함.
    
    but, 서명자의 개인키가 유출되면 다른 사람들이 서명 위조 가능.
    
    → 개인키는 보안적으로 안전한 장소에 보관되어야 함.
    
- 전자 서명 크기를 줄일 수 있고 해시 함수의 충돌 저항성을 활용해 위변조를 감지할 수 있음.
- 메시지의 기밀성은 보장하지 않음. 메시지의 무결성과 인증성은 보장 가능.
    - 메시지 유출은 될 수 있으나 메시지의 위변조는 감지할 수 있음.
        
        → 기밀성 보장을 위해서는 암호화 등의 방법을 사용하여 추가적인 보안 조치를 취해야 함.
        
<br/>

**💡 Attacks on Hash Functions**

브루트포스 어택을 당할 수 있다. 같은 해시값을 가지는 두 메시지 x, y가 존재할 수 있다.

→ 128 비트도 불충분함. 160비트는 돼야 함.

<br/>

**💡 Birthday Paradox**

64bit 해시 정도면 보안에 괜찮다고 생각할 수 있지만, 

birthday paradox에 의하면 아니다.

버스데이 패러독스에 의해 collision pair가 나올 확률 높음

if. 128비트의 해시 함수를 이용한다면, 2^64개의 입력값 생성하면 충돌값이 발생할 가능성이 높아짐.

→ 적어도 256 bits는 돼야 함.

RSA는 2048 bits, AS는 128 bits

→ RSA가 가장 긴 이유? : factoring(소인수분해)을 못하게 해야하기 때문

<br/>

**💡 Birthday Attack**

해시 함수의 충돌 가능성을 이용하여 디지털 서명을 위조하는 공격

1. 서명자가 서명할 메시지 선택 후 여러 개의 랜덤한 메시지 생성
    
    → 생성된 메시지들의 개수는 생일 파라미터의 제곱근에 비례하게 선택됨.
    
    → 생일 파라미터가 20(2k)이면 공격자는 2^10 (2^k)개의 랜덤한 메시지 생성함.
    
2. 공격자는 생성한 각각의 메시지들에 대해 해시 함수 계산함.
    
    → 충돌이 발생하는 해시값 쌍을 찾음.
    
    → 충돌이 발생하면, 이를 이용하여 디지털 서명 위조 가능
    
3. 생일 파라미터가 2*k이면 공격자는 2^k/2 개의 랜덤한 메시지 생성했을 때 충돌이 발생할 확률이 50퍼 이상임.

⇒ 공격 방지 방법 )

1. 공격 방지 위해 충돌 가능성이 낮은 안전한 해시 함수를 사용하거나,
2. 서명자의 개인키를 안전한 장소에 보관하여 외부로 유출되는 것을 방지
3. 생일 파라미터를 크게 설정하여 충돌 가능성을 낮추는 것도 도움이 됨

⇒ 충돌 쌍으로 디지털 서명 위조하는 방법 )

1. 두 개의 서로 다른 입력값을 조작하여 같은 해시값을 만들어 내는 것.
    
    ex. A, B 두 사람이 서로 다른 서명을 만들었지만 같은 해시값을 가진다면, 
    
    **A의 서명을 B의 서명으로 위조 가능.**
    
2. 충돌을 이용하여 공격자가 자신이 선택한 입력값과 
    
    실제 입력값이 다른 상황에서 동일한 해시값을 만들어내는 것.
    
    ex. 메시지의 인증 우회, 인증서 위조 가능
