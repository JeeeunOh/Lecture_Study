비대칭키 / 공개키 알고리즘보다 빠름.

`디지털 서명` : 비대칭키/공개키 : 두개의 다른키가 필요하고 적어도 2048 bits

`MAC` : 대칭키 : 같은 두개의 키, 1024 bits

<br/>

**💡 Message Authentication Code ( MAC )**

**메시지의 무결성과 신뢰성 인증**에 쓰이는 작은 크기의 정보

무결성 : 메시지 변조 여부

신뢰성 : 보낸 사람이 올바른지 여부

메시지와 공유된 비밀키를 사용하여 생성된 블록값으로 인증 가능.

→ `대칭키 암호화 알고리즘`. 암호화 & 복호화에 같은 키 사용

**동작 과정 :**

1. 송신자가 메시지와 공유된 비밀키를 이용하여 블록값 생성 알고리즘 
    
    ( 대칭키 암호화 알고리즘 - HMAC, CMAC 등 )으로 작은 블록값을 생성하여 메시지와 함께 전송
    

1. 수신자는 **수신된 메시지와 공유된 비밀키를 이용**하여 새로운 블록값을 생성합니다. 
    
    이 생성된 블록값과 수신된 블록값이 일치하는지를 확인하여 메시지의 무결성과 인증 여부를 판단
    
    수신된 블록값이 외부에서 변조되어 바뀌어도, 새로운 블록값을 생성하기 위해서는 
    
    공유된 비밀키가 필요하기 때문에 변조 여부를 감지 가능
    

**왜 사용?** 

- 때로는 메시지 암호화보다 authenticate(인증)하는 것이 더 중요함.
- 메시지 내용 유출에 크게 신경쓰지 않고
    
    이 메시지를 누가 보냈는지, 변경사항이 없는지 확인이 더 중요할 때 사용
    

 

→  MAC은 디지털 서명이 아니다. 

메시지의 기밀성을 보장하려면 대칭키 암호화 알고리즘을 사용하는 대신, 

공개키 암호화 알고리즘을 사용하는 디지털 서명 기술을 사용해야 함.

<br/>

**💡 MAC Properties**

- 비밀키 K를 이용해서 가변길이 M을 압축하여 고정크기로 만듦.
- many to one function이라 서로 다른 메시지들이 하나의 MAC을 가질 수 있음.
    
    그러나 이런 서로 다른 메시지들을 찾는 것은 어려움.
    
<br/>

**💡 Requirements for MACs**

- 메시지랑 MAC을 안다고 해서 같은 MAC을 가진 다른 메시지를 알 수 없다.
- MAC은 균등하게 분배되어있고 메시지의 모든 비트에 고루 의존해있다.

<br/>

**💡 Security of MACs**

`브루트포스 공격`

: strong collision resistance hash는 2^m/2 의 비용을 가짐.

→ 128비트 해시는 다소 취약함. 160 비트가 낫다.

: 알려진 MAC 쌍에 의해 공격 가능

→ 적어도 128 비트 필요

`암호 분석 공격 ( cryptanalytic attacks )`

: 더 다양한 MAC은 암호분석의 일반화를 어렵게 함.

<br/>

**💡 Keyed Hash Function as MACs**

**기존 MAC은 대칭키 암호화 알고리즘** 기반이었지만, 해시 함수를 이용하는 것이 일반적으로 더 빠르고 널리 사용가능하기 때문에 해시함수를 적용한 MAC이 논의되어 왔다.

이 때 원 목적은 `KeyedHash = Hash(Key|Message)` 였으나 암호화 키가 유출되거나 MAC 알고리즘에 취약점이 생기면 악의적인 공격자가 MAC 값을 조작하여 메시지 무결정을 위조할 수 있다는 문제점이 있다. 이에 이런 **취약점을 보완한 HMAC**이 나왔다.

<br/>

**💡 HMAC Design Objectives**

HMAC : MAC + 기밀성 / 해시함수 power에 비례

- 수정 없이 해시함수 사용
- 내장된 해시함수 쉽게 교체 가능
- 성능저하 없이 해시 함수의 원래 성능 유지

<br/>

**💡 HMAC**

동작과정 ) [( 링크 )](https://reakwon.tistory.com/103)

<br/>

**💡 HMAC Security**

- HMAC의 보안성은 해시함수에 달려있다.
- 가능한 공격
    - 브루트포스 공격
    - 버스데이 공격
- 해시함수를 속도 & 보안 측면에서 고려해서 골라야 함.

<br/>

**💡 Symmetric Ciphers for MACs**

- Data Authentication Algorithm(DAA)는 최근 많이 쓰는 MAC이다.

<br/>

**💡 Data Authentication Algorithm ( DAA )**

블록 암호화 기반의 MAC

전송된 데이터 블록의 암호화와 해싱 기술 사용

동작 과정 )

1. 전송된 메시지를 블록으로 분할한 후 블록을 DES를 이용해 암호화하고 
    
    이어서 블록의 다음 블록으로 전송함.
    
2. 마지막 블록을 MD5 해시함수로 해싱하여 전체 메시지의 해시값을 얻음.

한계점 )

DAA는 블록단위로 처리됨 → 큰 파일이나 스트리밍 데이터에 적합 X

암호화와 해시 함수의 연산을 반복해서 수행하기 때문에 성능이 떨어질 수 있음.

최종 MAC값이 너무 작음.

<br/>

**💡 CMAC**

- DAA의 한계를 보완하는 방법 )
    1. 2개의 서로 다른 서브키 사용 
        
        → DAA가 가지는 메시지 길이의 한계 극복 가능.
        
        같은 입력 메시지에 대해서도 다른 결과를 만들어 냄.
        
    2. DAA에서 사용되는 비밀번호와 같은 정보 사용 X
        
        → 랜덤한 수를 사용하여 MAC 값 계산
        
    3. **전체 메시지를 계산하는 대신, 메시지의 일부분만 계산하여 MAC 생성**
        
        → 사전 공격 방지 가능
        
        +) 사전 공격이란?
        
        해시 함수의 출력값으로부터 입력값을 찾아내는 공격.
        
        → 해시함수의 보안 강도가 중요하며 최신의 보안 알고리즘을 사용하고 
        
        충분한 길이의 출력값을 가지는 해시함수를 선택하여 사용해야 함.
        
        → DAA는 메시지 사이즈에 제한이 있는데 이를 해결 가능.
        

동작과정 )

메시지를 m bit씩 n개로 쪼갬. 

만약 메시지 블록이 m bit가 되지 X → 나머지 첫 비트는 1, 다른 비트는 0으로 채워버림

앞의 메시지 블록부터 차례대로 사전에 공유된 키로 암호화하고 암호화한 값을 이후의 블록과 xor

key로부터 파생된 k와 마지막블록의 xor 연산을 진행한 결과의 왼쪽 n bit를 메시지에 붙여서 보냄.

두 개의 서비스 중 하나는 중간 라운드에서 사용되는 K1, 다른 하나는 마지막 라운드에서 사용되는 K2

K1은 블록 처리 과정에서 생성된 다음 블록을 처리하기 전 현재 블록을 암호화하는데 사용됨.

K2 서브키는 마지막 블록을 처리하기 전 마지막 블록을 처리하는 동안 생성되며, 최종 MAC 값에 사용됨.

→   K1은 블록처리 중간에 메시지의 중간상태 보호를 위해, 

K2는 마지막 블록 처리 후 최종 MAC의 무결성을 검증하기 위해 사용됨.

<br/>

**💡 Counter with Cipher Block Chaining-Message Authentication Code ( CCM )**

암호화 & MAC을 위해 하나의 키를 사용함.

AES 암호화 블록 알고리즘을 사용함.

**동작과정 )**

CCM은 데이터 인증과 암호화를 위해 CTR 모드 및 CBC-MAC 모드를 결합하여 사용합니다. 메시지는 먼저 CTR 모드에서 암호화되고, CBC-MAC 모드에서는 메시지 블록의 해시를 계산합니다. 마지막으로, MAC 해시는 메시지 블록의 모든 해시 값에 대한 누적 XOR 결과입니다. CCM은 인증 키와 암호화 키가 동일한 키로 사용되므로 효율적입니다.

**다른 MAC과의 차이점 )**

CCM이 데이터를 암호화하면서 동시에 데이터 인증 가능.

추가적인 패딩이나 해시계산이 필요하지 않고 전체 메시지 길이에 대한 제한이 없음.
